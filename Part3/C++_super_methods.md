## move

## auto

## STL中的 unique_ptr 和 make_unique
inline

## explicit

## override

## nullptr和NULL的区别和联系

## C++的四种强制类型转换
#### C风格的强制类型转换

在C++基本的数据类型中，可以分为四类：整型，浮点型，字符型，布尔型。其中数值型包括 整型与浮点型；字符型即为char。

（1）将浮点型数据赋值给整型变量时，**舍弃**其小数部分。
（2）将整型数据赋值给浮点型变量时，数值不变，但是以指数形式存储。
（3）将double型数据赋值给float型变量时，注意数值范围溢出。
（4）字符型数据可以赋值给整型变量，此时存入的是字符的ASCII码。
（5）将一个int，short或long型数据赋值给一个char型变量，只将低8位原封不动的送到char型变量中。 
（6）将有符号型数据赋值给长度相同的无符号型变量，连同原来的符号位一起传送。

在C++语言中新增了四个关键字`static_cast`、`const_cast`、`reinterpret_cast`和`dynamic_cast`。这四个关键字都是用于强制类型转换的。

#### static_cast

**用法：static_cast <direction type_id> (origin expression)**

```cpp
int a = 10;
int b = 6;
double = static_cast<double>(a)/static_cast<double>(b);
```

**static_cast主要有如下几种用法：**

- 用于类层次结构中**基类**和**派生类**之间指针或引用的转换。

  - 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的

  - 进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的

- **可以实现C++中内置基本数据类型之间的相互转换**，如把int转换成char。这种转换的安全也要开发人员来保证
- 把空指针转换成目标类型的空指针
- 把任何类型的表达式转换为void类型



#### const_cast

**用法：const_cast <'origin' type_id> ('origin' expression)**

> const限定符通常被用来限定变量，用于表示该变量的值不能被修改。

**而const_cast则正是用于强制去掉这种不能被修改的常数特性，但需要特别注意的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。**

除了`const` 或`volatile`修饰之外， `type_id`和`expression`的类型是一样的。

> `volatile` 是一个关键字，用于声明一个变量是“易变”的，它告诉编译器不要对该变量进行优化，因为它的值可能会在程序的控制之外被改变。

**const_cast主要有如下几种用法：**

- 常量指针被转化成非常量指针，并且仍然指向原来的对象
- 常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。

错误用法：

```cpp
const int a = 10;
const int * p = &a;
*p = 20;                  //compile error, pointer decorated with const cann't be modified
int b = const_cast<int>(a);  //compile error, const_cast can only transfer the pointer or citation
```

**使用const_cast通常是一种无奈之举，同时建议C++程序设计过程中一定不要利用const_cast去掉指针或引用的常量性并且去修改原始变量的数值，这是一种非常不好的行为。**



#### reinterpret_cast

**用法：reinterpret_cast<type_id> (expression)**

`type-id`必须是一个指针、引用、算术类型、函数指针或者成员指针。
它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。

 **在使用reinterpret_cast强制转换过程仅仅只是比特位的拷贝，因此在使用过程中需要特别谨慎！**

**reinterpret_cast主要有如下几种用法：**

- 改变指针或引用的类型

- 将指针或引用转换为一个足够长度的整形

- 将整型转换为指针或引用类型

```cpp
int *a = new int;
double *d = reinterpret_cast<double *>(a);
```



#### dynamic_cast

**用法：dynamic_cast<type_id> (expression)**

注意：

- 上面三种都是编译时完成的，`dynamic_cast`是运行时完成的，运行中完成类型检查。

- 不能用于内置的基本数据类型的强制转换。

- `dynamic_cast`转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回`NULL`。

- 使用`dynamic_cast`进行转换的，基类中一定要有虚函数，否则编译不通过。

  > 基类中需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中。
  >
  > 只有定义了虚函数的类才有虚函数表。
  
- 在类的转换时，在类层次间进行上行转换时，`dynamic_cast`和`static_cast`的效果是一样的。在进行下行转换时，`dynamic_cast`具有类型检查的功能，比`static_cast`更安全。

  - 向上转换，即为子类指针指向父类指针（一般不会出问题）；向下转换，即将父类指针转化子类指针。

  - 向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。
  
    >  **在C++中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。`dynamic_cast`操作符则可以在运行期对可能产生问题的类型转换进行测试**

## exit()函数

必须包含头文件 `<cstdlib>`

以下是一些常见的退出代码及其含义：

- **0（或`EXIT_SUCCESS`）**：表示程序正常终止，没有发生错误。这是默认的退出状态码，通常表示成功执行。

- **非零值（通常为1，`EXIT_FAILURE`或其他整数）**：表示程序以某种方式失败或出现错误。具体的非零值通常由程序员根据需要选择，以指示不同类型的错误。

## RAII编程思想

RAII（Resource Acquisition Is Initialization）是一种编程思想，通常用于C++等编程语言中，旨在管理资源的生命周期和释放。它的核心思想是：资源的获取应该在对象的构造函数中完成，而资源的释放应该在对象的析构函数中完成。这样可以确保资源在对象生命周期结束时被正确释放，从而避免资源泄漏和内存泄漏等问题。

RAII的主要原则包括以下几点：

1. 资源获取：资源（如内存、文件句柄、数据库连接等）应该在对象的构造函数中进行获取。这意味着在创建对象时，资源应该被分配和初始化。
2. 资源释放：资源的释放应该在对象的析构函数中进行。当对象的生命周期结束时（例如，对象离开作用域或被显式删除），析构函数会自动调用，从而释放对象持有的资源。
3. 自动管理：RAII的一个关键特点是资源管理的自动化。程序员不需要手动调用资源的分配和释放函数，而是依赖对象的生命周期来管理资源。
4. 异常安全性：RAII还提供了异常安全性，因为如果在资源分配后发生异常，对象的析构函数会自动释放资源，而不会导致资源泄漏。

RAII的一个常见示例是使用智能指针（如`std::shared_ptr`和`std::unique_ptr`）来管理动态分配的内存。这些智能指针在构造时分配内存，在析构时释放内存，从而避免了内存泄漏问题。

总的来说，RAII是一种强大的编程模式，可以确保资源的正确管理，提高代码的可维护性和可靠性。它广泛应用于C++和其他支持对象生命周期管理的编程语言中。


## 输入输出
C语言的 sscanf 和 sprintf
对应着C++的 istringstream 和 ostringstream